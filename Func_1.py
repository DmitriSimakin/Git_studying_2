# -*- coding: utf-8 -*-
"""
Created on Wed May 12 14:55:51 2021

@author: Сергей Валентинович
"""
import numpy as np


def Print_Stop(s):
    print('  ')
    print('  ')
    print('  ')
    print('  ')
    print('********************************************************')
    print('********************************************************')
    print('********************************************************')
    print('  ')
    print(s)
    #stop
    return


def FindSpan (n,p,u,U): #A2.1, стр. 68
    #print("n=",n,"\np=",p,"\nu=",u,"\nU=",U,"  np.size(U)=",np.size(U))
#"""
#  n - кол-во Control Points (счёт от НУЛЯ)
#  p - степень полинома(=degree)
#  u - точка внутри РЕАЛЬНОГО диатазона в узловом векторе
#  U - узловой вектор - мах индекс в нем m=n+1+p
#"""

    for k in range(0,(np.size(U)-1)): 
        if (U[k]>U[k+1]): Print_Stop("** Сообщение из FindSpan -- Узловой вектор убывает (U[k]>U[k+1])")
        

    if ((np.size(U)-1) != (n+1+p)) : 
        Print_Stop("** Сообщение из FindSpan -- (size(U)-1)) Не Равен (n+1+p)");
        print("**  np.size(U)= ",np.size(U));
        print("n=",n,"\np=",p,"\nu=",u,"\nU=",U,"  np.size(U)=",np.size(U))
        print("*1* U=",U)
        #stop
                                  #stop
    if (u<U[p] or u>U[n+1]):  
        Print_Stop("** Сообщение из FindSpan -- u вышел за реальный диапазон -- (u<U[p] or u>U[n+1]), u=")
        print("  u=",u);
    
    if (u==U[n+1]):  
        return n # последний диапазон (начало диапазона), в котором может находиться u

   


#   далее идёт двоичный поиск

    low = p
    high = n+1
    mid=int( (low+high) / 2 )
    
    while ((u<U[mid]) or (u>=U[mid+1])):

        if u<U[mid]:
            high=mid
        else: 
            low=mid
               
        mid=int ((low+high)/2)
    
    
    return(mid)   

########################################################################################################################################################################
########################################################################################################################################################################


def BasisFuns(i,u,p,U,N): #A2.2, стр. 70

#!!!
#  Алгоритм расчитывает все ненулевые базис. функции  (НЕ Нулевые - в смысле только, например, 4-ре для кубич. полиномов)
#  для заданного аргумента ("u") 
#  и помещает их в массив N[0],...,N[p]
#!!!


#  i - номер диапазона для которого расчитывется N (N_i-p,p ... N_i,p)
#  u - значение u 
#  p - степень полинома (=degree)
#  U - узловой вектор
#  N - массив basis функций - N[0],...,N[p]
    
    left = np.zeros([p+1])
    rigth = np.zeros([p+1])
    
    N[0]=1.0
    for j in range(1,p+1):
        left[j]=u-U[i+1-j]
        rigth[j]=U[i+j]-u
        #print("j=",j+1)
        saved=0.0
        for r in range(j):
            temp=N[r]/(rigth[r+1] + left[j-r])
            N[r]=saved+rigth[r+1]*temp
            saved=left[j-r]*temp
            #print("   r=",r,temp,N[r],saved)
        N[j]=saved
    
     # Для контроля Суммируем значения Базис. Функций в точке "u".
    # Если все верно, то Сумма долж. быть =1
    
    Sum_N=np.sum(N) 
    
    if ((Sum_N<(1-1e-10))  or (Sum_N>(1+1e-10))) : 
        Print_Stop("** Сообщение из BasisFuns -- Сумма Базис. Функций НЕ РАВНА 1");
    
    return

########################################################################################################################################################################
########################################################################################################################################################################


def DersBasisFuns(i,u,p,n,U,ders): #A2.3, стр. 72

#!!!
#  Алгоритм расчитывает все ненулевые базис. функции (НЕ Нулевые - в смысле только, например, 4-ре для кубич. полиномов)
#  для заданного аргумента ("u") 
#  и все производные (от 0 до p) помещает их в 2D массив ders


#  i - номер диапазона (span) для которого расчитывется N (N_i-p,p ... N_i,p)
#  u - значение u 
#  p - степень полинома (=degree)
#  n - до какой степени расчитать производные Вазис. Функ. (n<=p)
#  U - узловой вектор
#  ders - массив basis функций  и их производных
#  ders[0][:] - базисные функции (N_i-p,p ... N_i,p)
#  ders[1][:] - 1-я производная базисных функций (N_i-p,p ... N_i,p)
#  ders[2][:] - 2-я производная базисных функций (N_i-p,p ... N_i,p)


    if (n>p) : 
        Print_Stop("** Сообщение из DersBasisFuns -- парядок производных НЕ МОЖЕТ БЫТЬ больше p");

    left = np.zeros([p+1])
    rigth = np.zeros([p+1])
    ndu = np.zeros([p+1,p+1])
    a = np.zeros([p+1,p+1])
    #n=p
    
    ndu[[0],[0]]=1.0
    for j in range(1,p+1):
        left[j]=u-U[i+1-j]
        rigth[j]=U[i+j]-u
        #print("j=",j+1)
        saved=0.0
        for r in range(0,j):
            #  Lower triangle
            ndu[[j],[r]]=rigth[r+1] + left[j-r]
            temp=ndu[[r],[j-1]]/ndu[[j],[r]]
            #  Upper triangle
            ndu[[r],[j]]=saved+rigth[r+1]*temp
            saved=left[j-r]*temp
            
        ndu[[j],[j]]=saved
        
    # Load the basis functions
    for j in range(0,p+1):
        ders[[0],[j]]=ndu[[j],[p]]
        
    # This section computes the derivatives (Eq. [2.9]) 
    
    for r in range(0,p+1): # Loop over function index
        s1=0; s2=1 # Alternate rows in array "a"
        #print("type(s1)=",type(s1), "type(s2)=",type(s2) ); 
        a[[0],[0]]=1.0
        
        for k in range(1,n+1): # Loop  to compute kth derivative
            d=0.0
            rk=r-k;  pk=p-k
            if (r>=k):
               a[[s2],[0]] = a[[s1],[0]]/ndu[[pk+1],[rk]] 
               d = a[[s2],[0]]*ndu[[rk],[pk]];
               
            if (rk >= -1): j1 = 1
            else: j1 = -rk;
            if (r-1 <= pk): j2 = k-1; 
            else: j2 = p-r;
            
            for j in range(j1,j2+1):
                a[[s2],[j]] = (a[[s1],[j]]-a[[s1],[j-1]])/ndu[[pk+1],[rk+j]]; 
                d += a[[s2],[j]]*ndu[[rk+j],[pk]]; 
            
            if (r <= pk):
               a[[s2],[k]] = -a[[s1],[k-1]]/ndu[[pk+1],[r]]; 
               d += a[[s2],[k]]*ndu[[r],[pk]]; 
            
            ders[[k],[r]] = d; 
            j=s1; s1=s2; s2=j;  # Switch rows    

     # Multiply through by the correct factors 
     # (Eq. [2.9])     
    r = p; 
    for k in range(1,n+1):
        for j in range(0,p+1):
           ders[[k],[j]] *= r; 
        r*= (p-k); 
            
        
    # Для контроля Суммируем значения Базис. Функций в точке "u".
    # Если все верно, то Сумма долж. быть =1
    
    Sum_N=np.sum(ders,axis=1)[0] 
    
    if ((Sum_N<(1-1e-10))  or (Sum_N>(1+1e-10))) : 
        Print_Stop("** Сообщение из DersBasisFuns -- Сумма Базис. Функций НЕ РАВНА 1")
        return
       
    
    
    
    return


########################################################################################################################################################################
########################################################################################################################################################################

def CurvePoin(n,p,U,P,u,C,N): #A3.1, стр. 82

#!!!
#  Алгоритм расчитывает для заданного "u" одну точку на В-сплайне 
# Input:
#  n - кол-во Control Points (счёт от НУЛЯ)
#  p - степень полинома(=degree)
#  U - узловой вектор - мах индекс в нем m=n+1+p
#  P - контрольные точки (control polygon)
#  u - точка внутри РЕАЛЬНОГО диатазона в узловом векторе

# Output:
#  C - для заданного "u" точка на В-сплайне 

#  Внутренний Массив "N" = Объявлен в Головной Программе
#  N - массив basis функций - N[0],...,N[p] для заданного "u"
#

    #print("n=",n,"\np=",p,"\nu=",u,"\nU=",U,"  np.size(U)=",np.size(U))
    #print("P=",P,"  np.size(P)=",np.size(U))

    span = FindSpan(n,p,u,U);
    #print("span=",span)
    BasisFuns(span,u,p,U,N);
    #print("N=",N)
    C[:] = 0.0;
    for i in range(0,p+1):
        C = C + N[i]*P[span-p+i];
    #print("C=",C)
    
    return (C)

########################################################################################################################################################################
########################################################################################################################################################################


def CurveDerivsAlgl(n,p,U,P,u,d,CK,nders) : #A3.2, стр. 93

#!!!
#  Алгоритм расчитывает для заданного "u" одну точку на Годографе Произ-
#  водных.
#  Расчитывается "d" производных от Нулевой до "d"-той (если "d>p", будут НУЛИ)
#


# Input:
#  n - кол-во Control Points (счёт от НУЛЯ)
#  p - степень полинома(=degree)
#  U - узловой вектор - мах индекс в нем m=n+1+p
#  P - контрольные точки (control polygon)
#  u - точка внутри РЕАЛЬНОГО диатазона в узловом векторе
#  d - мах порядок производных 

# Output:
#  CK - 1D массив, в которм хранятся производные

#  Внутренний Массив "N" = Объявлен в Головной Программе
#  N - массив basis функций - N[0],...,N[p] для заданного "u"
#

    du = min(d,p); 
  
    for k in range(p+1,d+1):   CK[k] = 0.0; 
    span = FindSpan(n,p,u,U); # print("span=",span)
    DersBasisFuns(span,u,p,du,U,nders); #print("nders=",nders,"\nCK=",CK)
    
    for k in range(0,du+1):    
    
        CK[k] = 0.0;
        for j in range(p+1): 
            #print("\nj=",j," k=",k," CK[k] =",CK[k],"nders[[k],[j]= ",nders[[k],[j]]," P[span-p+j]=",P[span-p+j])
            
            
            CK[k] = CK[k] + nders[[k],[j]]*P[span-p+j];




    return

########################################################################################################################################################################
########################################################################################################################################################################

########################################################################################################################################################################
########################################################################################################################################################################

def CurvePoin_and_Deriv(n,p,U,P,u,C2,nders): #A3.1, стр. 82

#!!!
#  Алгоритм расчитывает для заданного "u" одну точку на В-сплайне 
# Input:
#  n - кол-во Control Points (счёт от НУЛЯ)
#  p - степень полинома(=degree)
#  U - узловой вектор - мах индекс в нем m=n+1+p
#  P - контрольные точки (control polygon)
#  u - точка внутри РЕАЛЬНОГО диатазона в узловом векторе

# Output:
#  C - для заданного "u" точка на В-сплайне 

#  Внутренний Массив "N" = Объявлен в Головной Программе
#  N - массив basis функций - N[0],...,N[p] для заданного "u"
#

    #print("n=",n,"\np=",p,"\nu=",u,"\nU=",U,"  np.size(U)=",np.size(U))
    #print("P=",P,"  np.size(P)=",np.size(U))

    span = FindSpan(n,p,u,U);
    #print("span=",span)
    #BasisFuns(span,u,p,U,N);
    DersBasisFuns(span,u,p,p,U,nders); #print("nders=",nders)
    #print("N=",N)
   
    #print("type(C2)=",type(C2))
    #print("np.shape(C2)=",np.shape(C2))
    #print("np.size(C2)=",np.size(C2)) 
     
    C2[:,:]=0
    for j in range(0,p+1):
        for i in range(0,p+1):
        
            C2[j,:] = C2[j,:] + nders[[j],[i]]*P[span-p+i];
    #print("****C2=",C2)
    
    return (C2)

########################################################################################################################################################################
########################################################################################################################################################################


########################################################################################################################################################################
########################################################################################################################################################################

def CurvePoin_and_Deriv_NURBS(n,p,U,B,H,u,C2,nders): #A3.1, стр. 82

    """
    Алгоритм расcчитывает для заданного "u" одну точку на В-сплайне и 1-ю и 2-ю Производ. для этой точки
    Input:
    n - максимальный индекс в Определяющем Многоуголь.(счёт от НУЛЯ) 
    n = (n_ver-1)
    p - степень полинома(=degree)
    U - узловой вектор
    B - массив точкек Определяющем Многоуголь
    u - точка внутри РЕАЛЬНОГО диатазона в узловом векторе

    Output:
    C - для заданного "u" точка на В-сплайне 
    C[0,:] - x,y сплайна для заданного "u"
    C[1,:] - x,y Первой производной для заданного "u" (то есть для точки x,y(=C[0,:]) на сплайне)
    C[2,:] - x,y Второй производной для заданного "u" (то есть для точки x,y(=C[0,:]) на сплайне)
    nders  - массив для хранения Базисю функ. и их Произ. (Введён в параметры, что бы обявить Один раз в головной процедуре,
                                                           а не здесь при каждом вызове)
    """
    #print("**************************************************************")
    #print("n=",n,"\np=",p,"\nu=",u,"\nU=",U,"  np.size(U)=",np.size(U))
    #print("P=",P,"  np.size(P)=",np.size(U))

    span = FindSpan(n,p,u,U);
   
    #print("span=",span," u=",u)
  
    if ((np.shape(B)[0]-1) != (n)) : 
        Print_Stop("** Сообщение из CurvePoin_and_Deriv_NURBS -- (np.shape(P)[0]-1) Не Равен (n)");
  
    DersBasisFuns(span,u,p,p,U,nders); #print("nders=\n",nders)
    #print("np.sum(nders,axis=1)[0]=", np.sum(nders,axis=1)[0])
    #print("np.sum(nders,axis=1)[1]=", np.sum(nders,axis=1)[1])
   
    #print("type(P)=",type(P))
    #print("np.shape(P)=",np.shape(P))
    #print("np.shape(P)[0]=",np.shape(P)[0])
    #print("np.shape(P)[1]=",np.shape(P)[1])
    #print("np.size(P)=",np.size(P)) 
     
    C2[:,:]=0
   
    N0=np.zeros([2])  # Числитель формулы NURBS (формула 5-122, Роджерс (рус.) стр 360)  
    N0=0 # это "0", т.к. =np.zeros([2]), но пусть Будет
    
    D=0 # Знаменатель формулы NURBS (формула 5-122, Роджерс (рус.) стр 360)
   
    N1=np.zeros([2])  # Числитель Первого слагаемого формулы 1-ой Производ. NURBS (формула 5-126, Роджерс (рус.) стр 372)  
    N2=np.zeros([2])  # Множитель в Числителе Второго слагаемого формулы 1-ой Производ. NURBS (формула 5-126, Роджерс (рус.) стр 372)  
    N1=0
    N2=0
    
    N3=np.zeros([2])  # Мночитель в Числителе при расчёте 2-ой Производ. NURBS ((см. мои листы)  
    N4=np.zeros([2])  # Мночитель в Числителе при расчёте 2-ой Производ. NURBS ((см. мои листы) 
    N3=0
    N4=0
    
    
    #print("P=\n",P,"\nH=\n",H)
    #for j in range(0,p+1): # j=0 - кривая 
    
    j=0  # j=0 - кривая (нулевая производная)  
         #  используем строку "0" в "nders[[j],[i]]" - матрица базис. функций и их "p" производных              
    for i in range(0,p+1):  
            #print("j=",j," i=",i," nders[[j],[i]]=",nders[[j],[i]]," P[span-p+i]=",P[span-p+i]," H[span-p+i]=",H[span-p+i])
        
            #C2[j,:] = C2[j,:] + nders[[j],[i]]*P[span-p+i];
        N0 = N0 + B[span-p+i]*H[span-p+i]*nders[[j],[i]];
        D = D + nders[[j],[i]]*H[span-p+i];
            #print(" ************  Numerator =",Numerator," Denominator=",Denominator)
                
    C2[0,:]=N0/D
    #print("00**C2=",C2)
    
    j=1  # j=1 - 1-я производная
    for i in range(0,p+1):  
        #print("j=",j," i=",i," nders[[j],[i]]=",nders[[j],[i]]," P[span-p+i]=",P[span-p+i]," H[span-p+i]=",H[span-p+i])
        
          
        N1 = N1 + B[span-p+i]*H[span-p+i]*nders[[1],[i]];
        N2 = N2 + H[span-p+i]*nders[[1],[i]];
        
        #print(" ************  N1 =",N1," N2=",N2)
        #print(" ************  Denominator=",D)
        
            
    C2[1,:]=N1/D - (N0*N2)/(D**2)
    #print("11** C2=",C2," p=",p)
    if (p==1): return (C2)
  
    
    j=2  # j=3 - 2-я производная
    for i in range(0,p+1):  
        #print("j=",j," i=",i," nders[[j],[i]]=",nders[[j],[i]]," P[span-p+i]=",P[span-p+i]," H[span-p+i]=",H[span-p+i])
        
                  
        N3 = N3 + B[span-p+i]*H[span-p+i]*nders[[2],[i]];
        N4 = N4 + H[span-p+i]*nders[[2],[i]];
        
        #print(" ************  N3 =",N3," N4=",N4)
        #print(" ************  Denominator=",D)
        
            
    S1=N3/D - (N1*N2)/D**2
    NN=N1*N2
    NN_deriv=N1*N2 + N0*N4
    S2=NN_deriv/D**2 -(NN*2*N2)/D**4
    
    C2[2,:]=S1-S2
    #print("22** C2=",C2)
    
    return (C2)

########################################################################################################################################################################
#########################################################################################################################################################


def RefineKnotVectCurve(n,p,U,Pw,X,r,Ubar,Qw):

#    """
#Вставка нескольких Новых узлов в Узловой вектор

#Input:
#n = Кол-во точек в Контр. Многоуг. (!!! это Максимал. Индекс (т.е. от НУЛЯ))
#p = Степень Сплайна, который будем проводить после вставки узлов  
#U = Узлов. Вектор до Вставки Новых Узлов
#Pw = Контр. Многоуг до Вставки Новых Узлов
#X = вектор с узлами, которые необходимо вставить
#r = Максимал. Индекс вектора Х

#Output:
#Ubar = Узлов. Вектор ПОСЛЕ Вставки Новых Узлов
#Qw = Контр. Многоуг ПОСЛЕ Вставки Новых Узлов



#    print(" *** Из RefineKnotVectCurve *** n=",n," p=",p," r=",r)
#    print("*Pw=\n",Pw)
#    print("*U=",U)
#    print("*X=",X)
#    print("*Qw=\n",Qw)
   
   
   

   
    m = n+p+1; 
    a = FindSpan(n,p,X[0],U); #print("*** a=",a)
    b = FindSpan(n,p,X[r],U); 
    b = b+1;                  #print("*** b=",b)                

    
   #for (j=O; j<=a-p; j++): Qw [j ] = Pw [j]
    for j in range(0,a-p+1,+1): Qw [j ] = Pw [j]
    
    #for (j=b-1; j<=n; j++): Qw[j+r+1] = Pw[j]
    for j in range(b-1,n+1,+1): Qw [j+r+1] = Pw [j]
       
    #print("*Qw=\n",Qw)
    
  
    #for (j=O; j<=a; j++): Ubar[j] = U[j]
    for j in range(0,a+1,+1): Ubar[j] = U[j]

    #for (j=b+p; j<=m; j++): Ubar[j+r+1] = U[j]
    for j in range(b+p,m+1,+1): Ubar[j+r+1] = U[j]
    
    #print("*Ubar=",Ubar)
     

    i = b+p-1; k = b+p+r; 
    
    #for (j=r; j>=Oj j--):
    for j in range(r,0-1,-1):    
      # while (X[j] <= U[i] && i > a):
       while ((X[j] <= U[i]) and (i > a)):   
           Qw[k-p-1] = Pw[i-p-1] 
           Ubar[k] = U[i] 
           k = k-1; i = i-1
       Qw[k-p-1] = Qw[k-p]
       #for (l=1; l<=p; l++) :
       for l in range(1,p+1,+1):    
         ind = k-p+l;
         alfa = Ubar[k+l]-X[j]
         if (abs(alfa) == 0.0):
             Qw[ind-1] = Qw[ind]
         else:
             alfa = alfa/(Ubar[k+l]-U[i-p+l])
             Qw[ind-1] = alfa*Qw[ind-1] + (1.0-alfa)*Qw[ind]
        
       Ubar[k]=X[j]
       k = k-1
 
#    print("*Ubar=",Ubar)
#    print("*Qw=\n",Qw)             
             
            

    return

########################################################################################################################################################################
#########################################################################################################################################################


def Reduction_Degree_Bezier(n,p,Q,P_new):

#    """
# Понижение степени Безье-криво на ЕДИНИЦУ

#Input:
# n = Кол-во точек в исходном Контр. Многоуг. (!!! это Максимал. Индекс (т.е. от НУЛЯ))
# p = Степень Безье-кривой, которая проходит через исходный Контр.Многоуг. (исходный Контр.Многоуг.= Q)  
# Q = исходный Контр.Многоуг


#Output:
# P_new = Контр. Многоуг ПОСЛЕ Удаление Одного Узла

      if ( n != p ): Print_Stop("** Сообщение из Reduction_Degree_Bezier -- МАКСИМАЛЬНЫЙ ИНДЕКС МАССИВА НЕ РАВЕН СТЕПЕНИ  ( n != p )")
      
      if ( n != (np.shape(Q)[0]-1) ): Print_Stop("** Сообщение из Reduction_Degree_Bezier -- МАКИМАЛЬНЫЙ ВХОДНОГО МАССИВА НЕ РАВЕН ЗАДАННОЙ РАЗМЕРНОСТИ  ( n != (np.shape(Q)[0]-1))");     
      
      if ( p <= 2 ): Print_Stop("** Сообщение из Reduction_Degree_Bezier -- ПОРЯДОК ИСХОДНОГО СПЛАЙНА  НЕ МОЖЕТ БЫТЬ МЕНЬШЕ 3  ( p=2 или p=1 быть Не Может)");
 
      P_new[0]=Q[0]
      P_new[n-1]=Q[n]
      r=int((p-1)/2)
      print("**&&&  r=",r,"  type(r)=", type(r))   
 
      if (p%2 == 0): # Проверка на Четность p
          # Начало для Четного "р"
          
          # Для Четного "р" этот алгоритм позволяет 
          # минимальное значение "р=4 (т.е. Пять точек в Многоуголнике"). 
          # "p=2 этот алгоритм НЕ БЕРЁТ !!!! (хотя, если вручную сделать, то для "р=2 (Три точки), если понизить степень
          #                                   до "р=1" получим прямую, соединяющую 1-ю и 3-ю точки Многоугоугольника !!!, 
          #                                   НО АЛГОРИТМ ЭТОТ ВАРИАНТ НЕ БЕРЕТ!!!)        
         
          for i in range(1,r+1,+1):           
            P_new[i]=(Q[i]-(i/p)*P_new[i-1]) / (1.0-(i/p)); print("**&&& Четн - for 1 i=",i,"  (i/p)=", (i/p), " type(i/p)=",type(i/p) )
            
          for i in range(p-2,r-0,-1):
            print("**&&& Четн - for 2   i=",i,"  (i+1)/p)=", (i+1)/p, " type((i+1)/p)=",type((i+1)/p) )
            Alf_i=i/p
            P_new[i]=(Q[i+1]-(1.0- (i+1)/p)*P_new[i+1]) / ((i+1)/p); 
          # Окончание для Четного "р"
      else:
          # Начало для НеЧетного "р"
          
          # Для Четного "р" этот алгоритм позволяет 
          # минимальное значение "р=4 (т.е. Пять точек в Многоуголнике"). 
          # "p=2 этот алгоритм НЕ БЕРЁТ !!!! (хотя, если вручную сделать, то для "р=2 (Три точки), если понизить степень
          #                                   до "р=1" получим прямую, соединяющую 1-ю и 3-ю точки Многоугоугольника !!!, 
          #                                   НО АЛГОРИТМ ЭТОТ ВАРИАНТ НЕ БЕРЕТ!!!)        
         
          for i in range(1,r+0,+1):           
            P_new[i]=(Q[i]-(i/p)*P_new[i-1]) / (1.0-(i/p)); print("**&&& НеЧетн - for 1 i=",i,"  (i/p)=", (i/p), " type(i/p)=",type(i/p) )
            
          for i in range(p-2,r-0,-1):
            print("**&&& НеЧетн - for 2   i=",i,"  (i+1)/p)=", (i+1)/p, " type((i+1)/p)=",type((i+1)/p) )
            Alf_i=i/p
            P_new[i]=(Q[i+1]-(1.0- (i+1)/p)*P_new[i+1]) / ((i+1)/p); 
          
          Pr_L=(Q[r]-(r/p)*P_new[r-1]) / (1.0-(r/p)) 
          Pr_R=(Q[r+1]-(1.0- (r+1)/p)*P_new[r+1]) / ((r+1)/p)
          P_new[r]=0.5*(Pr_L+Pr_R)
          # Окончание для Не Четного "р"
      return